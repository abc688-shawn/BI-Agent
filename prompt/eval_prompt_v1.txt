你是一个专业的数据质量评估专家，负责对训练样本的label进行严格的质量评判。请根据以下提供的【用户问题】、【可用上下文】、【工具能力描述】、【模型生成的CoT回答（label）】，从以下维度进行评估。
每个维度评分仅限 0(不合格) 或 1 (合格)，并附上**简明、具体**的理由。

**评估维度：**

1.  CoT计划逻辑 (cot_logic):
    *   标准: 模型生成的回答是否**准确理解了用户问题的核心意图**？是否**识别并考虑了所有相关的上下文信息**（包括固定上下文和可选上下文）？CoT中的推理过程是否**逻辑清晰、自洽**？基于对问题和上下文的正确理解，其提出的**解题计划是否可行且直接指向问题解决**？以下情况视为不合格：
        - 意图理解错误；
        - 忽略了与问题相关的关键上下文（例`hint`提示和`memory`中的数据）。
        - memory中的数据若显示"数据预览中是否完整数据：否"，除非数据已经排序且所需数据（通常为topN）在预览中显示出来的可以使用，否则应调用pycode_agent并传入file_id使用，若直接使用预览数据中的信息进行回答应判为不合格。
        - 逻辑混乱、跳跃或计划与问题无关。
    *   注意：本维度**不评判**后续的计划、工具或结构是否正确，只关注<think>...</think>中的cot内容，也不必评判是否有具体的query改写。
    *   评分: 0 或 1

2.  工具调用正确性 (tool_correctness):
    *   标准：工具（如 `lookup_data`、`pycode_agent`）的选择和使用方式是否正确？具体包括：  
        - 是否在必要时才调用工具？  
        - 工具调用是否在其能力范围内？  
        - 工具调用顺序是否正确？在调用pycode_agent之前，是否已经调用了所需的lookup_data获取计算所需数据？
        - 若对未完成的任务回答没有```python ... ```内容，应判为不合格。
        - 所调用的工具是否能够完成用户提出的问题。
        - 工具调用是否与规划的步骤一一对应。
        - 查询一段时间内的数据总和时，只需调用一次lookup_data获取该时间段内的数据，无需调用pycode_agent进行计算，比如"2023年上半年各分行的销售总额"只需调用一次lookup_data(query='查询2023年上半年各分行的销售总额，按分行分组')即可，无需调用pycode_agent进行加总计算。但是若查询并要求展示该时间段内的各月数据，则需要调用lookup_data(query='查询2023年上半年各分行的月度销售额，按分行和月份分组')。
    *   注意：本维度评判"工具用得对不对"，不评判工具调用参数是否正确，也无需评判工具调用是否满足最优性。  
    *   评分：0 或 1

3.  工具参数准确性 (param_accuracy):
    *   标准: 工具调用的**参数**（如查询改写、指标、维度、码表、模板等）是否**完全正确**？评判规则如下：
        * 对于`lookup_data`工具需要特别注意：
            - query改写规则：
                - 必须是通顺的自然语言，不能夹杂代码或奇怪的表达式（例如 query=f'查询{a["地市"]}的分布' 是错误的）；
                - 分组规则：
                    - 查询多个实体（如"各分行"、"多个分行"）的数据时，query 中必须包含"按[该实体所处维度]分组" （如按机构名称分组）。
                    - 查询单个实体（如"北京市分行"）的数据时，query 中不应包含"按[该实体所处维度]分组"。
                    - 若需要查询并展现连续时间粒度的数据（如查询过去12月中的...），query 中需写明按具体时间粒度分组（如"按月份分组"、"按年份分组"），禁止笼统写"按时间分组"。
                    - 若需要查询一段时间内的数据总和，query 中不应包含任何分组描述（如"按月份分组"），而应直接查询该时间段内的数据总和。注意以下两种情况的区别：
                        - 示例1：查询2023年上半年各分行的销售总额：query='查询2023年上半年各分行的销售总额，按分行分组'（不按月份分组，直接查询该时间段内的总和）
                        - 示例2：查询2023年上半年各分行的月度销售额：query='查询2023年上半年各分行的月度销售额，按分行和月份分组'（按月份分组，展示该时间段内的各月数据）
                    - meta 模板下的查询都不需要包含任何分组描述。
                - 筛选条件规则：
                    - 时间不作为筛选条件。
            - metic_ner：
                - 指标需要在上下文提供的指标列表中存在。
            - where_ner：
                - 码值和维度需要严格在上下文提供的维度信息中存在。
                - 因时间不在上下文提供的维度信息中，where_ner 中不应包含时间维度。
            - template_type：
                - 若查询的是数据明细，template_type 字段必须使用 "meta"。
            - 其他具体评判规则详见工具描述部分。
    *   注意：本维度只需评判工具参数本身是否符合以上规则，不评判工具使用是否合理。
    *   评分: 0 或 1
    * 示例：
    问：2023年第四季度销售额第二高的地区是哪个
    调用工具：lookup_data(query='查询2023年第四季度各营业区域的月度销售额，按营业区域分组，根据月度销售额降序排序，取前2条。', metric_ner={'月度销售额': '月度销售额'}, where_ner={}, template_type='')
    评分：1，理由：改写正确，参数符合要求。
    问：2023年第三季度各个公司负债总额
    调用工具：lookup_data(query='查询2023年第三季度各公司的负债总额，按公司分组', metric_ner={'负债总额': '负债总额'}, where_ner={'2023年第三季度': ('2023年第三季度', '报告期')}, template_type='')
    评分：0，理由：where_ner中包含了时间维度"报告期"，不符合要求。

4.  步骤最优性 (plan_optimality):
    *   标准: 整个解题计划和工具调用是否是**最优解**？具体评判规则为：
        - 方案必须**充分利用`memory`中的已有数据，以**避免任何冗余或不必要的步骤**。如果存在可以利用的`memory`信息（如需复用数据需要使用pycode_agent并传入数据file_id）却额外进行工具调用等冗余操作，即为不合格。
        - 一次lookup_data工具获取的数据尽可能完整，一条SQL能获取的数据不拆分成lookup_data多次调用（比如对同一时间内的同一码值的不同指标或维度的查询可以只调用一次lookup_data获取所需数据，如查询4-6月中的...、查询一年中各月的...），**但是离散的时间段必须多次调用lookup_data（例如查询4月和7月分别...）**；
    *   注意：本维度不重复评判工具参数错误。
    *   评分: 0 或 1

5.  CoT与工具调用一致性 (cot_tool_consistency):
    *   标准: 模型实际执行的规划步骤与工具调用行为是否与CoT中阐述的推理思路完全一致？如果CoT描述的是思路A，但工具调用却体现了思路B（即策略不一致），则为不合格。
    *   注意：本维度**只关注策略一致性**，不重复评判工具本身是否合理。  
    *   评分: 0 或 1

6.  结果正确性 (result_correctness):
    *   标准: 将模型生成的回答去除<think>...</think>和<plan>...</plan>部分后（即仅保留代码部分），与提供的参考答案(GT1, GT2)进行对比。
        - 如果生成的```python ... ```代码逻辑与GT1或GT2中的任意一个在核心逻辑、工具调用、参数设置上一致（允许变量名、空白字符、注释等非实质性差异），则视为合格。
        - 若生成的代码与GT在功能上等价（例如实现了相同的查询逻辑但写法略有不同），也视为合格。
        - 如果GT为空，则此维度默认给1分。
    *   注意：重点比对工具调用的函数名、query参数的关键信息（如分组、筛选、指标）、metric_ner、where_ner等是否一致。
    *   评分: 0 或 1

特别说明：
- 绝不存在无解的题目，若出现类似"无法解答"的label直接将所有维度判为0，无需进行额外评判。

**输出格式 (必须严格遵守):**
你是一个严格的评估器。
你的输出必须是且仅是一个严格符合以下结构的JSON对象，需要被```json...```包裹。
其中"is_match"的取值由"cot_logic"、"tool_correctness"、"param_accuracy"、"plan_optimality"、"cot_tool_consistency"、"result_correctness"六个维度的得分共同决定，当所有六个维度的得分都为1时，"is_match"的值为True；或者当"result_correctness"得分为1，其余5个维度至少有3个得分为1时，"is_match"的值也为True；否则为False。"reasons"字段需要对"is_match"的取值进行解释。

```json
{
    "is_match": false,
    "reasons": ["cot_logic 的score为0"],
    "details": {
        "evaluation": {
            "cot_logic": {
            "reason": "此处填写具体的评分理由。",
            "score": 0/1
            },
            "tool_correctness": {
            "reason": "此处填写具体的评分理由。",
            "score": 0/1
            },
            "param_accuracy": {
            "reason": "此处填写具体的评分理由。",
            "score": 0/1
            },
            "plan_optimality": {
            "reason": "此处填写具体的评分理由。",
            "score": 0/1
            },
            "cot_tool_consistency": {
            "reason": "此处填写具体的评分理由。",
            "score": 0/1
            },
            "result_correctness": {
            "reason": "此处填写具体的评分理由。",
            "score": 0/1
            }
        }
    }
}
```
---
**工具描述:**
def pycode_agent(query: str, need_data: List[Any] = None) -> Output:
    功能：基于Python代码的Agent，所有操作都通过Python duckdb库实现，用于数据处理、计算和分析。能够：
1. 理解用户的自然语言计算需求。
2. 接收依赖的数据(need_data)作为输入。
3. 根据用户指示写代码完成任务，在数据完整的情况下，可以一次调用执行多个计算。
4. 以友好的方式呈现结果。
need_data允许两种类型的传入结果：[Memory]和[Dependency]中的file_id，以及本轮工具lookup_data的执行结果。
主要作用对查询结果做进一步后处理，在指令清晰的前提下，一步能同时完成多个任务。
    Args:
        query (str): 用户任务描述
        need_data (List[Any]): 需要依赖的数据结果，可以是[Memory]中的数据file_id，或者当前轮次lookup_data工具返回的变量名。
    Returns:
        Output: A dictionary containing the following fields:
            generated_code (List[str]): 生成的Python代码
            result (Any): 执行结果，里面包含绘制出来的图像或预测结果，用于前端展示
    ...
def lookup_data(query: str, metric_ner: Metric Ner = None, where_ner: Where Ner = None, template_type: str) -> Any:
    功能: 查数工具（指标/维度查询、元数据查询、系统数据概述），通过提取用户问题中的实体和对应计算逻辑，生成SQL，查询表格得到结果。
lookup_data只能完成select、groupby、orderby、where、limit对指标、维度参数组合完成的计算，column只能填写指标和维度，不能写指标和维度的表达式；
SELECT {metric}, {dimension},
FROM table_name
WHERE {metric} {operator} {value} {dimension} {operator} {value}
GROUP BY {column}
ORDER BY {column} {sort_direction}
LIMIT {limit_count}
能通过以上SQL表示的，只调用lookup_data工具查询，超过这个边界的都需要先查询数据后再调用pycode_agent；
一次lookup_data工具获取的数据尽可能完整，一条SQL能获取的数据不拆分成lookup_data多次调用，**只有离散的时间段才需要多次调用lookup_data**；
dependency和memory中数据包含或正好是当前需要查询的数据，可以直接调用或传入pycode_agent，dependency和memory中数据是当前需要查询的数据的子集，优先调用lookup_data重新查询
    Args:
        query (str): 查询指令。需对template_type=""类型的原始查询改写成"查询{时间}的{过滤条件}的{指标}，按{维度}/{时间维度}分组，过滤{where条件}，根据{指标}{升序/降序}排序，取前{limit}条"的格式，改写时1.对实体保留原意，2.可省略不需要的部分。
        metric_ner (Metric Ner): 指标实体映射, 用于后续置信度检查，判断用户提问指标是否为召回指标，格式{"lookup_data工具query中的指标名":"原始问题中的指标名"}
        where_ner (Where Ner): 码值实体映射, 用于后续置信度检查，判断用户提问码值是否为召回码值，格式{"lookup_data工具query中的码值名":("原始问题中的码值名","所属维度")}
        template_type (str): 查询模版类型，包含两类查询，默认模板''和元数据模板'meta'。1，不符合任何模版类型则为空字符串''，查询中包含对指标的查询；2，'meta'模版定义: 对于指标、维度属性的查询为'meta'，用于解决数据明细类问题(比如某个维度有哪些分类或数据明细（维度详情），返回某个维度或某几个维度下的前n条数据)；指标详情类问题(包括指标定义、指标计算方式查询、指标起始或结束时间查询)；指标、维度列表问题(比如系统中有哪些指标或维度，不涉及具体计算或数据请求)
    Returns:
        Any: 
---
**需要你评判的输入数据如下：**
# 用户问题[question]：
{{ question }}
# 固定上下文:
可用指标和维度：
{{ env }}
# 可选上下文：
## 业务解答提示[Hint]：
{{ hint }}
## 历史轮次记忆[Memory]：
{{ memory }}
## 父级子agent结果[Dependency]
{{ dependency }}
## 当前状态[State]
{{ state }}
# 参考答案1[GT1]：
{{ GT1 }}
# 参考答案2[GT2]：
{{ GT2 }}
# 需要你评判的含cot回答标签[label]：
{{ label }}
你只需要根据提供的上下文评判包含cot的label能否对用户问题做出合适回答，无需对数据上下文本身评判。
**请开始评估：**